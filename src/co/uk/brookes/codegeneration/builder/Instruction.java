package co.uk.brookes.codegeneration.builder;

import co.uk.brookes.symboltable.Obj;
import co.uk.brookes.symboltable.Struct;

/**
 * Author: Fantou Thomas
 * Date: 7/1/13
 */
public class Instruction {
    public static final int  // instruction codes
        pushselfid_      =  3,
        pop_             =  5,
        dup_             =  6,
        pushlistentry_   =  8,
        int2string_    = 13,
        if_    = 14,
        nop_      = 16,
        yield_      = 20,
        loadcaste_    = 21,
        agentnew_      = 22,
        agentalloc_       = 23,
        agentdealloc_         = 24,
        agentregister_         = 25,
        agentregisterpost_         = 26,
        agentready_         = 27,
        instanceof_         = 28,
        instanceset_  = 29,
        instancesetpost_ = 30,
        updatestate_ = 32,
        param_    = 35,
        paramstring_     = 36,
        patternexist_     = 38,
        patternmatch_ = 39,
        resetvar_ = 40,
        pushenvthruvar_     = 41,
        pushenvthrustate_ = 42,
        loaddll_   = 44,
        dllcall_     = 45,
        freedll_    = 46,
        output_     = 47,
        print_    = 48,
        openwindow_      = 49,
        setagentstate_      = 50,
        recordnew_ = 51,
        putfield_   = 52,
        getfield_   = 53,
        pulishstate_   = 54,
        listnew_   = 55,
        putentry__   = 56,
        getentry_   = 57;

    static public final String // instruction code
        push_ = "PUSH",
        typeint_ = "INT",
        typereal_ = "REAL",
        typestring_ = "STRING",
        setstate_ = "SETSTATE",
        upstate_ = "UPSTATE",
        pushconstantpoolasstring_ = "PUSHCONSTANTPOOLASSTRING",
        add_    = "ADD",
        sub_    = "SUB",
        mul_    = "MUL",
        div_    = "DIV",
        sendmessage_ = "SENDMESSAGE",
        pushstate_ = "PUSHSTATE",
        observe_ = "OBSERVE",
        return_ = "RETURN",
        quit_ = "QUIT",
        ifne_ = "IFNE",
        ifeq_ = "IFEQ",
        ifle_ = "IFLE",
        iflt_ = "IFLT",
        ifgt_ = "IFGT",
        jump_ = "JUMP",
        comparestring_ = "COMPARESTRING",
        setaction_ = "SETACTION",
        updateaction_ = "UPDATEACTION",
        pushvar_         =  "PUSHVAR",
        storevar_        =  "STOREVAR";

    static String tempAddress = ":tmpa:";
    static String tempInstructionIn = ":tmpi:"; //instruction pushing from [state|localvar] to the stack
    static String tempInstructionOut = ":tmpo:"; //instruction popping from the stack to [state|localvar]
    static String tempInstructionAddress = ":tmpia"; //this will need to be replaced by the address of either state or localvar

    public static final int  // instruction kind
        constant_ = 0,
        bytecode_     = 1;

    public static final int  // constant codes
        label_   = 0,
        state_  = 1,
        action_ = 2,
        env_    = 3,
        caste_  = 4,
        cons_   = 5;




    public int kind;    //constant or bytecode
    public int code;    //Constant : constant code (label,state,action...)
    public String insVal; //ByteCode : instruction code value
    public int index;   //Constants : element index param
    public int address; //bytecode pc/ state-env-action-cons address (same than those generated by CAVM)
    public String val;  //Constants(utf8) : xml value
    public String name; //Constants(state/env/action) : name node
    public int typeCode; //Constants(state) : struct type
    public String type; //Contants(env)
    public String scope;    //Constants(env) :
    public String casteName;    //Constants(env)
    public String url;  // Constants(env)

    public int nParam;   //Constants(action)
    public Obj params; //Constants(action) : parameters

    //caste constant : information
    public String[] cons;
    public String[] states;
    public String[] actions;
    public String[] envs;

    public Instruction() {

    }

    public Instruction(String code) {
        this.kind = bytecode_;
        this.insVal = code;
    }


    public void fixup(int address){
        this.insVal += " " + address;
    }

    //adding the address with a temp format, in the case of an action. the temp address will need to be fixed up when it is merging the program bytecode
    public void tempFixup(int address) {
        this.insVal += " " + tempAddress + address;
    }

    public int arrange(int address) {
        if(this.insVal.contains(tempAddress)) {
            String[] strs = this.insVal.split(tempAddress); //e.g JUMP :tmpa:33 -> JUMP|33
            int oldAddress = Integer.parseInt(strs[1]);
            int newAddress = oldAddress + address;
            this.insVal = strs[0] + newAddress;
        }
        //the other temporary instructions cannot be arranged on the first call, it need to request more information: the type of the param
        if(this.insVal.contains(tempInstructionIn)) {
            String[] strs = this.insVal.split(tempInstructionIn); //e.g :tmpi:1 -> ""|1
            int paramIdx = Integer.parseInt(strs[1]);
            return paramIdx;
        }
        if(this.insVal.contains(tempInstructionOut)) {
            String[] strs = this.insVal.split(tempInstructionOut); //e.g :tmpo:1 -> ""|1
            int paramIdx = Integer.parseInt(strs[1]);
            return paramIdx;
        }
        if(this.insVal.contains(tempInstructionAddress)) {
            String[] strs = this.insVal.split(tempInstructionAddress); //e.g :tmpia:1 -> ""|1
            int paramIdx = Integer.parseInt(strs[1]);
            return paramIdx;
        }
        return -1;
    }

    public void arrange2(int type, int address){
        switch(type) {
            case Obj.state_:
                if(this.insVal.contains(tempInstructionIn))
                    this.insVal = Instruction.pushstate_;
                else if(this.insVal.contains(tempInstructionOut))
                    this.insVal = Instruction.setstate_;
                else if(this.insVal.contains(tempInstructionAddress))
                    this.insVal = String.valueOf(address);
                break;
            case Obj.var_:
                if(this.insVal.contains(tempInstructionIn))
                    this.insVal = Instruction.pushvar_;
                else if(this.insVal.contains(tempInstructionOut))
                    this.insVal = Instruction.storevar_;
                else if(this.insVal.contains(tempInstructionAddress))
                    this.insVal = String.valueOf(address);
                break;
        }
    }

}
